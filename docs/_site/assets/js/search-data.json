{"0": {
    "doc": "Chapter 3",
    "title": "Chapter 3",
    "hpath": "Algorithm.DesignManualBook.chap3",
    "content": " ",
    "url": "http://localhost:4000/notes/05774b2e-ebf7-4bbc-8171-ad191ba0ae0a.html",
    "relUrl": "/notes/05774b2e-ebf7-4bbc-8171-ad191ba0ae0a.html"
  },"1": {
    "doc": "Chapter 3",
    "title": "LeetCode",
    "hpath": "Algorithm.DesignManualBook.chap3",
    "content": ". | Count of Smaller Numbers After Self . We have to see how many numbers are smaller to self on the right. Naive: Just interate for each element and check how many elements are smaller on the right for a given index - \\(O(n^2)\\) . Merge Sort : Posting an example for more clarity . void MergeSort(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;indices, vector&lt;int&gt; &amp;results, int start, int end){ int count = end-start; if(count &gt; 1){ int mid = start + count/2; MergeSort(nums,indices, results, start, mid); MergeSort(nums, indices, results, mid, end); vector&lt;int&gt; tmp; tmp.reserve(count); int idx1 = start, idx2 = mid; int smallcount=0; while(idx1 &lt; mid || idx2 &lt; end){ if((idx2 == end) || (idx1 &lt; mid &amp;&amp; nums[indices[idx1]] &lt;= nums[indices[idx2]])){ tmp.push_back(indices[idx1]); results[indices[idx1]] += smallcount; idx1++; } else{ tmp.push_back(indices[idx2++]); smallcount++; } } move(tmp.begin(), tmp.end(), indices.begin()+start); } } . | Construct Binary Tree from Preorder and Inorder Traversal . | . Two approaches: . | Recursive: Here we keep adding preorder entries into a tree. To differentiate b/w entries which will be in left/right subtree is done on the basis of Inorder vector. Seems \\(O(n^2)\\) as we need to find the inorder entry idx for each preorder idx. | . private: TreeNode* build(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt;&amp; inorder, int start, int end, int&amp; idx){ if(start &gt; end){ return NULL; } TreeNode* node = new TreeNode(preorder[idx++]); int it = find(inorder.begin()+start, inorder.end(), preorder[idx-1]) - inorder.begin(); node-&gt;left = build(preorder, inorder, start, it-1, idx); node-&gt;right = build(preorder, inorder, it+1, end, idx); return node; } public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { int idx=0; return build(preorder, inorder, 0, inorder.size()-1, idx); } . | Stack : This is new for me. \\(O(n)\\). Here is the initution: . We know that preorder transversal is as follows: . | node | node-&gt;left | node-&gt;right . So we always transverse a left node in preorder until there are none left(I hope you got the pun). How do we know that there is no left subtree after a point? Answer from Inorder transversal . The inorder transversal can be shown as follows: . | node-&gt;left | node | node-&gt;right . so We store the left most node of the tree in the beginning. then the second most and the list goes on. so what we can do is: . | . | Make a stack of nodes with the first entry as preorder[0] | Keep assuming that the next entry is a left child until the top of the stack matches the inorder[0]. this means we have reached the left mode node | now pop the stack until we have s.top() == inorder[j] or s.empty(). | Once this is done, we can see that the left most node of the remaining tree is part of the right subtree of the node. | So we will assign the next node as right child. | to keep track of the right child we can keep a flag which resets after assigning the next node as right child. | . | . public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { if(!preorder.size()) return NULL; stack&lt;TreeNode*&gt; st; TreeNode* root = new TreeNode(preorder[0]); st.push(root); int i=1, j=0, flag=0; TreeNode* t = root; while(i &lt; preorder.size()){ if(!st.empty() &amp;&amp; st.top()-&gt;val == inorder[j]){ t = st.top(); flag = 1; st.pop(); j++; } else{ if(flag){ flag=0; t-&gt;right = new TreeNode(preorder[i++]); t = t-&gt;right; st.push(t); } else{ t-&gt;left = new TreeNode(preorder[i++]); t = t-&gt;left; st.push(t); } } } return root; } . ",
    "url": "http://localhost:4000/notes/05774b2e-ebf7-4bbc-8171-ad191ba0ae0a.html#leetcode",
    "relUrl": "/notes/05774b2e-ebf7-4bbc-8171-ad191ba0ae0a.html#leetcode"
  },"2": {
    "doc": "DesignManualBook",
    "title": "DesignManualBook",
    "hpath": "Algorithm.DesignManualBook",
    "content": " ",
    "url": "http://localhost:4000/notes/066ccb60-a0d7-4b3f-af88-3432ef01935f.html",
    "relUrl": "/notes/066ccb60-a0d7-4b3f-af88-3432ef01935f.html"
  },"3": {
    "doc": "About me",
    "title": "About Me",
    "hpath": "self",
    "content": "My name is Prabhsimrandeep Singh. Currently I work in Juniper networks as a timing engineer. I work on implemeting clocking and synchronization protocols like syncE and PTP. I am a big fan of TV shows. In my free time, I go to hacker news to get some tech gossip. ",
    "url": "http://localhost:4000/notes/1d49cbf3-7a35-4a45-a047-c0170981979c.html#about-me",
    "relUrl": "/notes/1d49cbf3-7a35-4a45-a047-c0170981979c.html#about-me"
  },"4": {
    "doc": "About me",
    "title": "About me",
    "hpath": "self",
    "content": " ",
    "url": "http://localhost:4000/notes/1d49cbf3-7a35-4a45-a047-c0170981979c.html",
    "relUrl": "/notes/1d49cbf3-7a35-4a45-a047-c0170981979c.html"
  },"5": {
    "doc": 404,
    "title": "404",
    "hpath": null,
    "content": "Page not found . ",
    "url": "http://localhost:4000/404.html#404",
    "relUrl": "/404.html#404"
  },"6": {
    "doc": 404,
    "title": 404,
    "hpath": null,
    "content": " ",
    "url": "http://localhost:4000/404.html",
    "relUrl": "/404.html"
  },"7": {
    "doc": "Exercises",
    "title": "Exercises",
    "hpath": "Algorithm.DesignManualBook.chap4.Exercises",
    "content": ". | 4.4 - Counting sort . | 4-11 Design an O(n) algorithm that, given a list of n elements, finds all the elements that appear more than n/2 times in the list. Then, design an O(n) algorithm that, given a list of n elements, finds all the elements that appear more than \\(n/4\\) times. We can get the solution using something similar to tetris Game. Credits: GoG. we can solve for any n/k in O(nk) time. Here is the intuition: . | create a temp array of size k-1 | iterate over the elements of the array. For each element add it into temp array and increment its count | when the temp array is filled and a new element comes, delete the count of each entry in the temp array and ignore the element. | follow the above steps till the end. | now user needs to verify for each element y in temp, iterating over the array. to make sure each element occurs more than n/k times. | . | . void moreThanNdK(int arr[], int n, int k) { // k must be greater than // 1 to get some output if (k &lt; 2) return; /* Step 1: Create a temporary array (contains element and count) of size k-1. Initialize count of all elements as 0 */ struct eleCount temp[k - 1]; for (int i = 0; i &lt; k - 1; i++) temp[i].c = 0; /* Step 2: Process all elements of input array */ for (int i = 0; i &lt; n; i++) { int j; /* If arr[i] is already present in the element count array, then increment its count */ for (j = 0; j &lt; k - 1; j++) { if (temp[j].e == arr[i]) { temp[j].c += 1; break; } } /* If arr[i] is not present in temp[] */ if (j == k - 1) { int l; /* If there is position available in temp[], then place arr[i] in the first available position and set count as 1*/ for (l = 0; l &lt; k - 1; l++) { if (temp[l].c == 0) { temp[l].e = arr[i]; temp[l].c = 1; break; } } /* If all the position in the temp[] are filled, then decrease count of every element by 1 */ if (l == k - 1) for (l = 0; l &lt; k; l++) temp[l].c -= 1; } . ",
    "url": "http://localhost:4000/notes/6b9c2b74-68aa-468e-a8fb-44925c159f75.html",
    "relUrl": "/notes/6b9c2b74-68aa-468e-a8fb-44925c159f75.html"
  },"8": {
    "doc": "Home",
    "title": "Welcome to the DEN",
    "hpath": "root",
    "content": "This is the root of my vault. If you decide to visit my github page, this will be your landing page. I have build this website using dendron. It’s an open source project. Really Awesome. ",
    "url": "http://localhost:4000/#welcome-to-the-den",
    "relUrl": "/#welcome-to-the-den"
  },"9": {
    "doc": "Home",
    "title": "What’s it about",
    "hpath": "root",
    "content": "I plan to use this to jot down my notes for some of the problems I have worked on. ",
    "url": "http://localhost:4000/#whats-it-about",
    "relUrl": "/#whats-it-about"
  },"10": {
    "doc": "Home",
    "title": "Home",
    "hpath": "root",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"11": {
    "doc": "ExercisesNotes",
    "title": "LeetCode",
    "hpath": "Algorithm.DesignManualBook.chap4.LeetCode",
    "content": " ",
    "url": "http://localhost:4000/notes/e05247c2-9939-4f60-a5d5-52c4280d92e7.html#leetcode",
    "relUrl": "/notes/e05247c2-9939-4f60-a5d5-52c4280d92e7.html#leetcode"
  },"12": {
    "doc": "ExercisesNotes",
    "title": "Binary Index Tree/ Fenwick Tree",
    "hpath": "Algorithm.DesignManualBook.chap4.LeetCode",
    "content": "This is useful for cases when we need to perform two types of operation on an array: . | updating arr[i] | operation which involves arr[0],…, arr[i] eg: sum(0, a[i]), max(0, a[i]) | . We can see that in normal case, update step takes O(1) time and 2nd operation takes O(n) time. Using BIT, we can run both these steps at O(log n). Same is the use case for segment trees. Here we will consider BIT tree where the 2nd operation is sum. First step is the update step. Here is the code(credits:GOG): . // Returns sum of arr[0..index]. This function assumes // that the array is preprocessed and partial sums of // array elements are stored in BITree[]. int getSum(int BITree[], int index) { int sum = 0; // Initialize result // index in BITree[] is 1 more than the index in arr[] index = index + 1; // Traverse ancestors of BITree[index] while (index&gt;0) { // Add current element of BITree to sum sum += BITree[index]; // Move index to parent node in getSum View // Intuition: // index = a1b (where b are all zeros and 1 represents the least set bit) // we have -index = 2's complement of index i.e. a'0b' + 1 = a'1b //index &amp; (-index) = a1b &amp; a'1b = 010 (least set bit of index) // in this step we are removing the last set bit of index in each iteration // index &amp; (-index) index -= index &amp; (-index); } return sum; } // Updates a node in Binary Index Tree (BITree) at given index // in BITree. The given value 'val' is added to BITree[i] and // all of its ancestors in tree. void updateBIT(int BITree[], int n, int index, int val) { // index in BITree[] is 1 more than the index in arr[] index = index + 1; // Traverse all ancestors and add 'val' while (index &lt;= n) { // Add 'val' to current node of BI Tree BITree[index] += val; // Update index to that of parent in update View index += index &amp; (-index); } } . ",
    "url": "http://localhost:4000/notes/e05247c2-9939-4f60-a5d5-52c4280d92e7.html#binary-index-tree-fenwick-tree",
    "relUrl": "/notes/e05247c2-9939-4f60-a5d5-52c4280d92e7.html#binary-index-tree-fenwick-tree"
  },"13": {
    "doc": "ExercisesNotes",
    "title": "ExercisesNotes",
    "hpath": "Algorithm.DesignManualBook.chap4.LeetCode",
    "content": " ",
    "url": "http://localhost:4000/notes/e05247c2-9939-4f60-a5d5-52c4280d92e7.html",
    "relUrl": "/notes/e05247c2-9939-4f60-a5d5-52c4280d92e7.html"
  },"14": {
    "doc": "Algorithms",
    "title": "Algorithms",
    "hpath": "Algorithm",
    "content": "These are my Notes when I was reading the book: The Algorithm Design manual . I have jotted down the solutions for some of the coding problems I liked. ",
    "url": "http://localhost:4000/notes/e86ac3ab-dbe1-47a1-bcd7-9df0d0490b40.html",
    "relUrl": "/notes/e86ac3ab-dbe1-47a1-bcd7-9df0d0490b40.html"
  },"15": {
    "doc": "Chapter 4",
    "title": "Sorting",
    "hpath": "Algorithm.DesignManualBook.chap4",
    "content": " ",
    "url": "http://localhost:4000/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#sorting",
    "relUrl": "/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#sorting"
  },"16": {
    "doc": "Chapter 4",
    "title": "Heap Sort",
    "hpath": "Algorithm.DesignManualBook.chap4",
    "content": "Constructing a heap takes O(n) time. removing min/max element causes O(log n) which turn to O(nlog n) for n elements. Selection Sort - we partition the input array into sorted and unsorted regions. To find the smallest item, we performed a linear sweep through the unsorted portion of the array. The smallest item is then swapped with the \\(ith\\) item in the array before moving on to the next iteration. Selection sort performs n iterations, where the average iteration takes \\(n/2\\) steps, for a total of \\(O(n^2)\\) time. Heap Sort can be seen as improved version of selection sort. We are just using a better data structure. In selection sort, swap takes \\(O(1)\\) time. but getting minimum item takes \\(O(n)\\). But we can use a data structure like priority queues/ BST which has \\(O(n)\\) search time which reduces time complexity to \\(O(nlog n)\\) . ",
    "url": "http://localhost:4000/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#heap-sort",
    "relUrl": "/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#heap-sort"
  },"17": {
    "doc": "Chapter 4",
    "title": "Merge Sort",
    "hpath": "Algorithm.DesignManualBook.chap4",
    "content": "The most important thing to remember here is that divide and conquer is your friend. It’s always useful. so keep it in mind when going through the problems. you can use it a lot of times. Not just for Sorting. ",
    "url": "http://localhost:4000/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#merge-sort",
    "relUrl": "/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#merge-sort"
  },"18": {
    "doc": "Chapter 4",
    "title": "Quick Sort",
    "hpath": "Algorithm.DesignManualBook.chap4",
    "content": "Have read this too many times. But now comes the intuition. One thing which is important is elements less than p are in range [0, firsthigh) so firsthigh is never part of that bunch. So when we swap s[i] and s[firsthigh], we are just swaping s[i](&lt; p) with s[firsthigh](&gt;= p). also we don’t include pivot element in the loop because it won’t make a change as for i=p, s[i] = s[p]. p = h; /* select last element as pivot */ firsthigh = l; for (i = l; i &lt; h; i++) { if (s[i] &lt; s[p]) { swap(&amp;s[i], &amp;s[firsthigh]); firsthigh++; } } swap(&amp;s[p], &amp;s[firsthigh]); . Randomized Algorithms . Quicksort can be improved upon by randomizing the input set. This can still give the worst case but it won’t be dependent on the input itself. Such randomization can help us in preventing worst case for a certain input. ",
    "url": "http://localhost:4000/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#quick-sort",
    "relUrl": "/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#quick-sort"
  },"19": {
    "doc": "Chapter 4",
    "title": "Wiggle Sort",
    "hpath": "Algorithm.DesignManualBook.chap4",
    "content": "This can be done in O(n) time by doing a single traversal of given array. The idea is based on the fact that if we make sure that all even positioned (at index 0, 2, 4, ..) elements are greater than their adjacent odd elements, we don’t need to worry about odd positioned element. // This function sorts arr[0..n-1] in wave form, i.e., arr[0] &gt;= // arr[1] &lt;= arr[2] &gt;= arr[3] &lt;= arr[4] &gt;= arr[5] .... void sortInWave(int arr[], int n) { // Traverse all even elements for (int i = 0; i &lt; n; i+=2) { // If current even element is smaller than previous if (i&gt;0 &amp;&amp; arr[i-1] &gt; arr[i] ) swap(&amp;arr[i], &amp;arr[i-1]); // If current even element is smaller than next if (i&lt;n-1 &amp;&amp; arr[i] &lt; arr[i+1] ) swap(&amp;arr[i], &amp;arr[i + 1]); } } . ",
    "url": "http://localhost:4000/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#wiggle-sort",
    "relUrl": "/notes/fe757956-ec54-49f4-a59c-87a93281efef.html#wiggle-sort"
  },"20": {
    "doc": "Chapter 4",
    "title": "Chapter 4",
    "hpath": "Algorithm.DesignManualBook.chap4",
    "content": " ",
    "url": "http://localhost:4000/notes/fe757956-ec54-49f4-a59c-87a93281efef.html",
    "relUrl": "/notes/fe757956-ec54-49f4-a59c-87a93281efef.html"
  }
}
